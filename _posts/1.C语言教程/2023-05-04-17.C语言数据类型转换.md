计算机进行算术运算时，要求各操作数的类型具有相同的大小（存储位数）及存储方式，不能将
char 型（ 1 字节）数据与 int 型（
2、4或8字节）数据直接参与运算；由于存储方式的不同，也不能将 int 型数据与
double 型数据直接参与运算。

然而，由于 C
语言的灵活性，在一个表达式或一条语句中，允许不同类型的数据混合运算。

C
语言的灵活性与计算机的机械性是一对矛盾，如处理不好，将会产生错误结果。对于某些类型的转换编译器可隐式地自动进行，不需程序员干预，称这种转换为**自动类型转换**；而有些类型转换需要程序员显式指定，这种类型转换称为**强制类型转换**。

# 一、自动类型转换

一个表达式中出现不同类型间的混合运算，较低类型将自动向较高类型转换。

不同数据类型之间的差别在于数据的取值范围和精度上，一般情况下，数据的取值范围越大、精度越高，其类型也越"高级"。

整型类型级别从低到高依次为：

signed char-\>unsigned char-\>short-\>unsigned short-\>int-\>unsigned
int-\>long-\>unsigned long

浮点型级别从低到高依次为：

float-\>double

float浮点类型被我们弃用了，所以不提它了。

## 1、操作数中没有浮点型数据时

当 char、unsigned char、short 或 unsigned short
出现在表达式中参与运算时，一般将其自动转换为 int 类型。

int 与 unsigned int混合运算时，int自动转换为unsigned int型。

int、unsigned int 与 long 混合运算时，均转换为 long 类型。

## 2、操作数中有浮点型数据时

当操作数中含有浮点型数据时，所有操作数都将转换为 double 型。

例如：

[int ii=100;]{.mark}

[double dd=200.5;]{.mark}

[ii+dd;]{.mark}

上述算术表达式中操作数 dd 为double，所以先把
ii转换为double浮点数后再参与运算，运算结果为双精度浮点数300.5。

## 3、赋值运算符两侧的类型不一致时

当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型提升/降低为左值类型。例如：

[double dd;]{.mark}

[dd=10; // 右值为双精度，左值为整数]{.mark}

由于左值dd为双精度浮点型，所以先把右值整型常量10
提升为双精度浮点型后，再赋值给 dd，不但不丢失精度反而提高了精度。

[int ii;]{.mark}

[ii=10.5; // 右值10.5为双精度，左值为整型]{.mark}

右值双精度型 10.5 降低为左值整型，即10.5舍弃小数部分后，把10
赋给整型变量 ii，这种情况会丢失精度。

## 4、右值超出左值类型范围时

更糟糕的情况是，赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。例如：

char c; // char占8位，取值范围是-128-127。

c=1025; // 整数1025 对应二进制形式是100 0000 0001，超出了8位。

printf(\"%d\",c) ; // 以十进制输出c的值

该输出结果为 1，因为只取 1025 低 8 位 0000 0001（值为1），赋给字符型变量
c，得到毫无意义的值。

# 二、强制类型转换

虽然自动类型转换不需要人工干预，使用方便，但有利也有弊，尤其当自动类型转换是从较高类型转换为较低类型时，将会降低精度或截断数据，可能得不到预期的结果。

为了给程序设计人员提供更多的类型转换控制权限，使程序设计更加灵活，转换的目的更加清晰，C
语言提供了可显式指定类型转换的语法，通常称之为强制类型转换。

强制类型转换的格式为：

[ (目标类型) 表达式;]{.mark}

例如：

[int a,b;]{.mark}

[a=4;]{.mark}

[b=3;]{.mark}

[double dd;]{.mark}

[dd=a/b; // dd的结果将是1。]{.mark}

[dd=(double)(a/b); // dd的结果是1.000000。]{.mark}

[dd=(double)a/b; // dd的结果是1.333333]{.mark}

dd=a/b，dd的结果是1，这个很好理解，因为整数除整数还是整数，没有小数部分。

dd=(double)(a/b)，dd的结果也是1.000000，这个不好理解，它的运算过程是：

（1）先运算a/b，得到的结果是整数的1；

（2）把整数的1转换成double，是1.000000。

dd=(double)a/b，dd的结果是1.333333，这个也不好理解，它的运算过程是：

（1）先执行(double)a，把a转换为double，即4.000000；

（2）把4.00000除以3，得到1.333333，符合自动类型转换的规则。

这里还有个问题，程序员搞不清楚是(double)a优先还是a/b优先，最好的办法是写成这样((double)a)/b，这样就没有疑问了。

# 三、课后作业

编写示例程序，把本章节介绍的知识点全部演示一遍，用程序演示可以加深您的理解和映象。

# 四、版权声明

C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。

来源：C语言技术网（[www.freecplus.net](http://www.freecplus.net)）

作者：码农有道
